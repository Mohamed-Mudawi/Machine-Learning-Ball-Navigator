# Obstacle Navigation Intelligent Pathfinding System

Most of the project is displayed to the user through Python Turtle. 

An all-black ball, on the top left of the Turtle screen, is trying to reach a square all-green goal. However, there are obstacles which the user will create. These obstacles may block the ball’s path to the goal, but the ball must navigate through these obstacles to find a path to the goal. 

When the program is first run, the user gets to draw obstacles. The user can press up, down, left, or right to draw in their respective directions, press space to lift/lower the pen and press backspace to end the drawing process and move on to the next portion of the program. The user may draw whatever they want, wherever they want, but the user must make it possible for there to be at least a space the ball can fit through to reach the goal, or else the ball will be stuck and won’t be able to reach the goal. Also, it’s important that the user doesn’t draw in the area of the ball when it spawns, or else the ball will merge into the obstacle and glitch, which will affect the learning process. The left, right, top, and bottom edges of the screen will also act as obstacles so that the ball doesn’t go off-screen.

Once the user is done creating the obstacles, the ball will head directly toward the goal, assuming there are no obstacles in its way, to reach the goal in the fastest possible manner. Once the ball touches the goal, the program will end. However, the user will most likely create various obstacles to obscure the ball’s path. To navigate through these obstacles, the ball has many algorithms that almost always guarantee it finds a way to the goal, given that the user has completely blocked the ball from the goal. 

When the ball encounters an obstacle, it will bounce off of it, keep moving for a few seconds for the user to see it bounced off, and the ball will be reset, but now the ball will know that there is an obstacle there. The ball recognizes four different types of obstacles, a right-bounce, left-bounce, up-bounce, and down-bounce, and when the ball touches them it will bounce in its that direction. 

The ball has a sort of attraction to the goal, like a gravitational pull. So if the ball’s direction is changed then it will fix it to go back to the goal. When the ball hits an obstacle, depending on the degree it was going before it hit it, it will move a little left, right, up, or down the next time the ball resets so that it can avoid the obstacle. To determine if it should go left, right, up, or down, it will see the way it bounced, and what degree it had before it hit it. If the ball was headed more right than left before it hit a horizontal obstacle, it would avoid it by moving more right. If the ball was headed more up than down before it hit a vertical obstacle, it would avoid it by moving more up. If it avoids the obstacle and hits it again and bounces in the same direction, then that means that the obstacle is long, so it will move even more left, right, up, or down. It will keep doing this until it scales the entire obstacle and finds an end to it where the ball doesn’t bounce anymore.

But most likely, the user will make complex obstacles with dead ends that will be difficult using that algorithm alone. To fix this, if the ball is scaling an obstacle that goes in one direction and encounters another that goes in a different direction, instead of going in the direction it would have gone if it wasn’t scaling the obstacle, it will just hug the two obstacles. For example, if the ball was scaling an up-bounce obstacle by going right and encounters a left-bounce, originally it should go from going right to going down when it reached the left-bounce because the ball will be going more down than up when it hit the left-bounce, but instead it goes up so that it doesn’t get stuck in that corner. This algorithm also applies to all sides and corners. 

The ball is only able to scale up-bounce and left-bounce obstacles because of the goal’s pull, and if it tries to scale other obstacles it will be pulled away. To fix this, right-bounce and down-bounce obstacles are scaled differently. Instead of moving directly left, right, up, or down and going on it way, after the ball is moved the degree is changed to plus or minus 45 degrees so that the ball hits the obstacle if it is present. This removes the issue of the ball being pulled away while it’s scaling the obstacle.

If the ball hits an obstacle in the same location twice, instead of going in the same direction it went in, it will go in a different direction to remove the possibility of the ball being stuck.
